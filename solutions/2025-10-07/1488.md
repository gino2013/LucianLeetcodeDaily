# 1488. Avoid Flood in The City

## Problem Description

**Difficulty**: Medium

Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.

Given an integer array rains where:
- rains[i] > 0 means there will be rains over the rains[i] lake.
- rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.

Return an array ans where:
- ans.length == rains.length
- ans[i] == -1 if rains[i] > 0.
- ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.

## Solution Approach

### Method: Greedy with Priority Queue

The key insight is that when we encounter a rainy day for a lake that's already full, we need to have dried that lake on some previous dry day. We use a greedy strategy to always use the earliest available dry day to prevent flooding.

### Algorithm Steps:

1. Track full lakes and their last rain day in a dictionary
2. Use a min-heap to store available dry days
3. For each rainy day, check if the lake is already full
4. If full, find an available dry day between the last rain and today to dry it
5. If no such day exists, return empty array (impossible to avoid flood)
6. Fill remaining dry days with any valid lake number

## Code Implementation

```python
from typing import List
import heapq

class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        ans = []
        full_lakes = {}  # lake -> day it became full
        dry_days = []    # min heap of available dry days

        for i, lake in enumerate(rains):
            if lake > 0:
                # It's raining on this lake
                ans.append(-1)

                if lake in full_lakes:
                    # Lake is already full, need to check if we can dry it
                    # Find a dry day after the lake became full but before today
                    last_full_day = full_lakes[lake]
                    found = False

                    # Look for a dry day we can use
                    temp_days = []
                    while dry_days:
                        dry_day = heapq.heappop(dry_days)
                        if dry_day > last_full_day and dry_day < i:
                            # Use this dry day to dry the lake
                            ans[dry_day] = lake
                            found = True
                            break
                        else:
                            temp_days.append(dry_day)

                    # Put back unused dry days
                    for day in temp_days:
                        heapq.heappush(dry_days, day)

                    if not found:
                        return []  # Impossible to avoid flood

                # Mark this lake as full
                full_lakes[lake] = i

            else:
                # No rain today, we can choose to dry a lake
                ans.append(1)  # Placeholder, will be updated if needed
                heapq.heappush(dry_days, i)

        # Fill remaining dry days with any valid lake (or 1)
        while dry_days:
            dry_day = heapq.heappop(dry_days)
            ans[dry_day] = 1

        return ans
```

## Complexity Analysis

- **Time Complexity**: O(n log n) - Each day might involve heap operations
- **Space Complexity**: O(n) - For storing full lakes and dry days

## Example Tests

**Example 1:**
```
Input: rains = [1,2,3,4]
Output: [-1,-1,-1,-1]
Explanation: No dry days available, but no floods occur since no lake gets rained on twice
```

**Example 2:**
```
Input: rains = [1,2,0,0,2,1]
Output: [-1,-1,2,1,-1,-1]
Explanation: Dry lake 2 on day 2, dry lake 1 on day 3 to prevent floods
```

**Example 3:**
```
Input: rains = [1,2,0,1,2]
Output: []
Explanation: Impossible to avoid flood - only one dry day but need to dry both lakes
```

## Key Points

1. Use greedy strategy to allocate dry days optimally
2. Track when each lake becomes full to determine valid dry days
3. Use min-heap to efficiently find earliest available dry day
4. Return empty array if flooding is unavoidable

---

# 1488. 未知問題

## 問題描述

**難度**: Medium

1488. Avoid Flood in The City

## 解題思路

### 方法：[演算法名稱]

<!-- 請在此處描述解題思路 -->

### 算法步驟:

1. <!-- 步驟 1 -->
2. <!-- 步驟 2 -->
3. <!-- 步驟 3 -->

## 代碼實現

```python
from typing import List

class Solution:
    def solve(self, nums: List[int]) -> int:
        # TODO: 實現 未知問題
        # 請根據 LeetCode 問題要求修改方法名和參數類型
        pass
```

## 複雜度分析

- **時間複雜度**: O(?) <!-- 請填入時間複雜度 -->
- **空間複雜度**: O(?) <!-- 請填入空間複雜度 -->

## 範例測試

**Example 1:**
```
Input: 
Output: 
Explanation: 
```

## 關鍵要點

1. <!-- 關鍵點 1 -->
2. <!-- 關鍵點 2 -->
3. <!-- 關鍵點 3 -->
