# 3477. Fruits Into Baskets II / 水果放入籃子 II

## 問題描述 / Problem Description

給定兩個長度為 n 的整數陣列 `fruits` 和 `baskets`，其中：
- `fruits[i]` 表示第 i 種水果的數量
- `baskets[j]` 表示第 j 個籃子的容量

You are given two arrays of integers, `fruits` and `baskets`, each of length n, where:
- `fruits[i]` represents the quantity of the ith type of fruit
- `baskets[j]` represents the capacity of the jth basket

水果必須按照以下規則放置：
The fruits must be placed according to these rules:

1. 每種水果類型必須放在容量大於等於該水果數量的**最左邊可用**籃子中  
   Each fruit type must be placed in the **leftmost available** basket with a capacity greater than or equal to the quantity of that fruit type
2. 每個籃子只能裝一種水果  
   Each basket can hold only one type of fruit
3. 如果某種水果無法放入任何籃子，則保持未放置狀態  
   If a fruit type cannot be placed in any basket, it remains unplaced

返回經過所有可能的分配後仍未放置的水果種類數量。  
Return the number of fruit types that remain unplaced after all possible allocations are made.

## 解題思路 / Solution Approach

### 方法：貪心算法 / Method: Greedy Algorithm

這是一個貪心分配問題，核心思路是：  
This is a greedy allocation problem with the core idea:

1. 按順序處理每種水果 / Process each fruit type in order
2. 對於每種水果，從左到右尋找第一個容量足夠且未使用的籃子 / For each fruit, find the first available basket with sufficient capacity from left to right
3. 如果找到合適的籃子就放入，否則計為未放置 / If a suitable basket is found, place it; otherwise, count as unplaced

### 算法步驟 / Algorithm Steps:

1. 創建一個布林陣列記錄每個籃子的使用狀態  
   Create a boolean array to track the usage status of each basket
2. 遍歷每種水果類型  
   Iterate through each fruit type
3. 對於每種水果，從左到右查找第一個滿足條件的籃子：  
   For each fruit, search from left to right for the first basket that meets the criteria:
   - 籃子未被使用 / Basket is not used
   - 籃子容量 >= 水果數量 / Basket capacity >= fruit quantity
4. 如果找到合適籃子則標記為已使用，否則增加未放置計數  
   If a suitable basket is found, mark it as used; otherwise, increment the unplaced count
5. 返回未放置的水果種類數量  
   Return the number of unplaced fruit types

## 代碼實現 / Code Implementation

```python
from typing import List

class Solution:
    def basketsToRemove(self, fruits: List[int], baskets: List[int]) -> int:
        # 記錄已使用的籃子 / Track used baskets
        used_baskets = [False] * len(baskets)
        unplaced_count = 0
        
        # 遍歷每種水果 / Iterate through each fruit type
        for fruit_quantity in fruits:
            placed = False
            
            # 從左到右找第一個容量足夠且未使用的籃子 / Find the leftmost available basket with sufficient capacity
            for i in range(len(baskets)):
                if not used_baskets[i] and baskets[i] >= fruit_quantity:
                    # 將水果放入這個籃子 / Place the fruit into this basket
                    used_baskets[i] = True
                    placed = True
                    break
            
            # 如果沒有找到合適的籃子，計數未放置的水果 / If no suitable basket found, count as unplaced
            if not placed:
                unplaced_count += 1
        
        return unplaced_count
```

## 複雜度分析 / Complexity Analysis

- **時間複雜度 / Time Complexity**：O(n²)，其中 n 是水果的數量。對於每個水果，在最壞情況下可能需要掃描所有 n 個籃子。  
  O(n²), where n is the number of fruits. For each fruit, we might need to scan all n baskets in the worst case.
- **空間複雜度 / Space Complexity**：O(n)，其中 n 是籃子的數量。用於 `used_baskets` 布林陣列。  
  O(n), where n is the number of baskets. This is for the `used_baskets` boolean array.

## 範例測試 / Example Tests

**範例 1 / Example 1：**
```
輸入 / Input：fruits = [4,2,5], baskets = [3,5,4]
輸出 / Output：1
解釋 / Explanation：
- fruits[0] = 4 放入 baskets[1] = 5 / fruits[0] = 4 is placed in baskets[1] = 5
- fruits[1] = 2 放入 baskets[0] = 3 / fruits[1] = 2 is placed in baskets[0] = 3
- fruits[2] = 5 無法放入 baskets[2] = 4（容量不足）/ fruits[2] = 5 cannot be placed in baskets[2] = 4 (insufficient capacity)
- 有 1 種水果未放置 / 1 fruit type remains unplaced
```

**範例 2 / Example 2：**
```
輸入 / Input：fruits = [3,6,1], baskets = [6,4,7]
輸出 / Output：0
解釋 / Explanation：
- fruits[0] = 3 放入 baskets[0] = 6 / fruits[0] = 3 is placed in baskets[0] = 6
- fruits[1] = 6 無法放入 baskets[1] = 4，但可以放入 baskets[2] = 7 / fruits[1] = 6 cannot be placed in baskets[1] = 4, but can be placed in baskets[2] = 7
- fruits[2] = 1 放入 baskets[1] = 4 / fruits[2] = 1 is placed in baskets[1] = 4
- 所有水果都成功放置 / All fruits are successfully placed
```

## 關鍵要點 / Key Points

1. **最左邊優先 / Leftmost Priority**：必須選擇最左邊滿足條件的籃子 / Must select the leftmost basket that meets the criteria
2. **一對一映射 / One-to-One Mapping**：每個籃子只能裝一種水果 / Each basket can hold only one type of fruit
3. **貪心策略 / Greedy Strategy**：按順序處理，不需要回溯或重新分配 / Process in order, no need for backtracking or reallocation