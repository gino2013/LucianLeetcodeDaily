# 1161. Maximum Level Sum of a Binary Tree

## Problem Description

**Difficulty**: Medium

1161. Maximum Level Sum of a Binary Tree
Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.
Return the smallest level x such that the sum of all the values of nodes at level x is maximal.
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2

## Solution Approach

### Method: Breadth-First Search (BFS) / Level-Order Traversal

This problem requires us to traverse the binary tree level by level, calculate the sum of node values at each level, and track which level has the maximum sum. BFS is the perfect approach for this as it naturally processes nodes level by level.

### Algorithm Steps:

1. Initialize a queue with the root node and variables to track max_sum, max_level, and current_level
2. While the queue is not empty, process all nodes at the current level:
   - Calculate the sum of all node values at this level
   - Add children of current nodes to the queue for the next level
3. After processing each level, compare its sum with max_sum and update if current level has a larger sum
4. Return the level with maximum sum

## Code Implementation

```python
from typing import Optional
from collections import deque

class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 1

        max_sum = float('-inf')
        max_level = 1
        current_level = 1

        queue = deque([root])

        while queue:
            level_size = len(queue)
            level_sum = 0

            # Process all nodes at current level
            for _ in range(level_size):
                node = queue.popleft()
                level_sum += node.val

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # Update max if current level has larger sum
            if level_sum > max_sum:
                max_sum = level_sum
                max_level = current_level

            current_level += 1

        return max_level
```

## Complexity Analysis

- **Time Complexity**: O(n) - We visit each node in the tree exactly once, where n is the number of nodes
- **Space Complexity**: O(w) - Where w is the maximum width of the tree (maximum number of nodes at any level). In the worst case of a complete binary tree, this is O(n/2) = O(n)

## Example Tests

**Example 1:**
```
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
```

**Example 2:**
```
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
```

## Key Points

1. Use BFS (level-order traversal) to process nodes level by level
2. Track level_size before processing each level to know how many nodes belong to current level
3. Use `float('-inf')` as initial max_sum to handle cases where all node values are negative
4. Return the smallest level when there are ties (achieved by using `>` instead of `>=` in comparison)

---

# 1161. 未知問題

## 問題描述

**難度**: Medium

1161. Maximum Level Sum of a Binary Tree
Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.
Return the smallest level x such that the sum of all the values of nodes at level x is maximal.
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2

## 解題思路

### 方法：廣度優先搜索 (BFS) / 層序遍歷

此問題需要我們逐層遍歷二元樹，計算每一層節點值的總和，並追蹤哪一層的總和最大。BFS 是完美的方法，因為它自然地逐層處理節點。

### 算法步驟:

1. 用根節點初始化佇列，並初始化變數來追蹤 max_sum、max_level 和 current_level
2. 當佇列不為空時，處理當前層的所有節點：
   - 計算此層所有節點值的總和
   - 將當前節點的子節點加入佇列以處理下一層
3. 處理完每一層後，將其總和與 max_sum 比較，若當前層總和更大則更新
4. 返回總和最大的層級

## 代碼實現

```python
from typing import Optional
from collections import deque

class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 1

        max_sum = float('-inf')
        max_level = 1
        current_level = 1

        queue = deque([root])

        while queue:
            level_size = len(queue)
            level_sum = 0

            # 處理當前層的所有節點
            for _ in range(level_size):
                node = queue.popleft()
                level_sum += node.val

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # 如果當前層總和更大，則更新最大值
            if level_sum > max_sum:
                max_sum = level_sum
                max_level = current_level

            current_level += 1

        return max_level
```

## 複雜度分析

- **時間複雜度**: O(n) - 我們恰好訪問樹中的每個節點一次，其中 n 是節點數量
- **空間複雜度**: O(w) - 其中 w 是樹的最大寬度（任一層的最大節點數）。在完全二元樹的最壞情況下，這是 O(n/2) = O(n)

## 範例測試

**Example 1:**
```
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
```

**Example 2:**
```
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
```

## 關鍵要點

1. 使用 BFS（層序遍歷）逐層處理節點
2. 在處理每一層之前追蹤 level_size，以知道有多少節點屬於當前層
3. 使用 `float('-inf')` 作為初始 max_sum，以處理所有節點值都是負數的情況
4. 當有相同總和時返回較小的層級（通過在比較中使用 `>` 而不是 `>=` 來實現）
