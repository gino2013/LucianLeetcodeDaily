# 2943. Maximize Area of Square Hole in Grid

## Problem Description

**Difficulty**: Medium

2943. Maximize Area of Square Hole in Grid
You are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1.
You can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed.
Return an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).
Input: n = 2, m = 1, hBars = [2,3], vBars = [2]
Output: 4
Explanation:
The left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars are [1,2,3].
One way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.
Input: n = 1, m = 1, hBars = [2], vBars = [2]
Output: 4
Explanation:
To get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.
Input: n = 2, m = 3, hBars = [2,3], vBars = [2,4]
Output: 4
Explanation:
One way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.

## Solution Approach

### Method: Longest Consecutive Sequence

The key insight is that to form a square hole, we need to remove consecutive bars. Removing k consecutive horizontal bars creates k+1 horizontal spaces, and similarly for vertical bars. To form a square, we take the minimum of the two dimensions.

### Algorithm Steps:

1. Sort both hBars and vBars arrays
2. Find the longest consecutive sequence in hBars (e.g., [2,3,4] has length 3)
3. Find the longest consecutive sequence in vBars
4. The side length of the square is min(max_consecutive_h, max_consecutive_v) + 1
5. Return side_length²

## Code Implementation

```python
from typing import List

class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def find_max_consecutive(bars: List[int]) -> int:
            if not bars:
                return 0
            bars.sort()
            max_len = 1
            current_len = 1

            for i in range(1, len(bars)):
                if bars[i] == bars[i-1] + 1:
                    current_len += 1
                    max_len = max(max_len, current_len)
                else:
                    current_len = 1
            return max_len

        max_hBars = find_max_consecutive(hBars)
        max_vBars = find_max_consecutive(vBars)

        size = min(max_hBars, max_vBars) + 1
        return size * size
```

## Complexity Analysis

- **Time Complexity**: O(h log h + v log v) where h = len(hBars), v = len(vBars). Dominated by sorting.
- **Space Complexity**: O(1) excluding the space for sorting (or O(h + v) if counting sort space)

## Example Tests

**Example 1:**
```
Input: n = 2, m = 1, hBars = [2,3], vBars = [2]
Output: 4
Explanation:
The left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars are [1,2,3].
One way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.
```

**Example 2:**
```
Input: n = 1, m = 1, hBars = [2], vBars = [2]
Output: 4
Explanation:
To get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.
```

**Example 3:**
```
Input: n = 2, m = 3, hBars = [2,3], vBars = [2,4]
Output: 4
Explanation:
One way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.
```

## Key Points

1. Removing k consecutive bars creates k+1 spaces (not k)
2. For a square hole, we need equal horizontal and vertical dimensions
3. We use the minimum of the two dimensions to ensure it forms a square
4. Sorting helps identify consecutive sequences efficiently

---

# 2943. 未知問題

## 問題描述

**難度**: Medium

2943. Maximize Area of Square Hole in Grid
You are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1.
You can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed.
Return an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).
Input: n = 2, m = 1, hBars = [2,3], vBars = [2]
Output: 4
Explanation:
The left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars are [1,2,3].
One way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.
Input: n = 1, m = 1, hBars = [2], vBars = [2]
Output: 4
Explanation:
To get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.
Input: n = 2, m = 3, hBars = [2,3], vBars = [2,4]
Output: 4
Explanation:
One way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.

## 解題思路

### 方法：最長連續序列

關鍵洞察是要形成正方形洞，我們需要移除連續的條。移除 k 個連續的水平條會創建 k+1 個水平空間，垂直條同理。要形成正方形，我們取兩個維度的最小值。

### 算法步驟:

1. 對 hBars 和 vBars 數組進行排序
2. 找到 hBars 中最長的連續序列（例如 [2,3,4] 長度為 3）
3. 找到 vBars 中最長的連續序列
4. 正方形的邊長是 min(max_consecutive_h, max_consecutive_v) + 1
5. 返回邊長的平方

## 代碼實現

```python
from typing import List

class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def find_max_consecutive(bars: List[int]) -> int:
            if not bars:
                return 0
            bars.sort()
            max_len = 1
            current_len = 1

            for i in range(1, len(bars)):
                if bars[i] == bars[i-1] + 1:
                    current_len += 1
                    max_len = max(max_len, current_len)
                else:
                    current_len = 1
            return max_len

        max_hBars = find_max_consecutive(hBars)
        max_vBars = find_max_consecutive(vBars)

        size = min(max_hBars, max_vBars) + 1
        return size * size
```

## 複雜度分析

- **時間複雜度**: O(h log h + v log v) 其中 h = len(hBars), v = len(vBars)。主要由排序決定。
- **空間複雜度**: O(1) 不包括排序空間（或 O(h + v) 如果計算排序空間）

## 範例測試

**Example 1:**
```
Input: n = 2, m = 1, hBars = [2,3], vBars = [2]
Output: 4
Explanation:
The left image shows the initial grid formed by the bars. The horizontal bars are [1,2,3,4], and the vertical bars are [1,2,3].
One way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.
```

**Example 2:**
```
Input: n = 1, m = 1, hBars = [2], vBars = [2]
Output: 4
Explanation:
To get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.
```

**Example 3:**
```
Input: n = 2, m = 3, hBars = [2,3], vBars = [2,4]
Output: 4
Explanation:
One way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.
```

## 關鍵要點

1. 移除 k 個連續的條會創建 k+1 個空間（不是 k 個）
2. 要形成正方形洞，需要相等的水平和垂直維度
3. 我們使用兩個維度的最小值以確保形成正方形
4. 排序有助於高效識別連續序列
