# 3479. Fruits Into Baskets III

## Problem Description

**Difficulty**: Medium

You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
Each basket can hold only one type of fruit.
If a fruit type cannot be placed in any basket, it remains unplaced.
Return the number of fruit types that remain unplaced after all possible allocations are made.

Example 1:
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.

## Solution Approach

### Method: [Algorithm Name]

<!-- Please describe the solution approach here -->

### Algorithm Steps:

1. <!-- Step 1 -->
2. <!-- Step 2 -->
3. <!-- Step 3 -->

## Code Implementation

```python
from typing import List

class Solution:
    def basketsToRemove(self, fruits: List[int], baskets: List[int]) -> int:
        # Track used baskets
        # 記錄已使用的籃子
        used_baskets = [False] * len(baskets)
        unplaced_count = 0
        
        # Iterate through each fruit type
        # 遍歷每種水果
        for fruit_quantity in fruits:
            placed = False
            
            # Find the leftmost available basket with sufficient capacity
            # 從左到右找第一個容量足夠且未使用的籃子
            for i in range(len(baskets)):
                if not used_baskets[i] and baskets[i] >= fruit_quantity:
                    # Place the fruit into this basket
                    # 將水果放入這個籃子
                    used_baskets[i] = True
                    placed = True
                    break
            
            # If no suitable basket found, count as unplaced
            # 如果沒有找到合適的籃子，計數未放置的水果
            if not placed:
                unplaced_count += 1
        
        return unplaced_count
```

## Complexity Analysis

- **Time Complexity**: O(?) <!-- Please fill in time complexity -->
- **Space Complexity**: O(?) <!-- Please fill in space complexity -->

## Example Tests

**Example 1:**
```
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.
```

**範例 1:**
```
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.
```

## Key Points

1. <!-- Key point 1 -->
2. <!-- Key point 2 -->
3. <!-- Key point 3 -->

---

# 3479. 水果成籃 III

## 問題描述

**難度**: Medium

You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
Each basket can hold only one type of fruit.
If a fruit type cannot be placed in any basket, it remains unplaced.
Return the number of fruit types that remain unplaced after all possible allocations are made.

Example 1:
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.

## 解題思路

### 方法：[演算法名稱]

<!-- 請在此處描述解題思路 -->

### 算法步驟:

1. <!-- 步驟 1 -->
2. <!-- 步驟 2 -->
3. <!-- 步驟 3 -->

## 代碼實現

```python
from typing import List

class Solution:
    def basketsToRemove(self, fruits: List[int], baskets: List[int]) -> int:
        # Track used baskets
        # 記錄已使用的籃子
        used_baskets = [False] * len(baskets)
        unplaced_count = 0
        
        # Iterate through each fruit type
        # 遍歷每種水果
        for fruit_quantity in fruits:
            placed = False
            
            # Find the leftmost available basket with sufficient capacity
            # 從左到右找第一個容量足夠且未使用的籃子
            for i in range(len(baskets)):
                if not used_baskets[i] and baskets[i] >= fruit_quantity:
                    # Place the fruit into this basket
                    # 將水果放入這個籃子
                    used_baskets[i] = True
                    placed = True
                    break
            
            # If no suitable basket found, count as unplaced
            # 如果沒有找到合適的籃子，計數未放置的水果
            if not placed:
                unplaced_count += 1
        
        return unplaced_count
```

## 複雜度分析

- **時間複雜度**: O(?) <!-- 請填入時間複雜度 -->
- **空間複雜度**: O(?) <!-- 請填入空間複雜度 -->

## 範例測試

**Example 1:**
```
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.
```

**範例 1:**
```
Input: fruits = [4,2,5], baskets = [3,5,4]
Output: 1
Explanation:
fruits[0] = 4 is placed in baskets[1] = 5.
fruits[1] = 2 is placed in baskets[0] = 3.
fruits[2] = 5 cannot be placed in baskets[2] = 4.
```

## 關鍵要點

1. <!-- 關鍵點 1 -->
2. <!-- 關鍵點 2 -->
3. <!-- 關鍵點 3 -->
