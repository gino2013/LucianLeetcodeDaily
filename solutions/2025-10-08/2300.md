# 2300. Successful Pairs of Spells and Potions

**Difficulty**: <span style="color:orange">Medium</span>
**Topics**: `Array`, `Two Pointers`, `Binary Search`, `Sorting`
**Companies**: Amazon, Google, Microsoft

---

## üìã Problem Description

You are given two positive integer arrays:
- `spells` of length `n` - where `spells[i]` represents the strength of the i<sup>th</sup> spell
- `potions` of length `m` - where `potions[j]` represents the strength of the j<sup>th</sup> potion

You are also given an integer `success`.

A **spell-potion pair is successful** if:
```
spells[i] √ó potions[j] >= success
```

**Return** an integer array `pairs` of length `n` where `pairs[i]` is the number of potions that will form a successful pair with the i<sup>th</sup> spell.

### Example 1:
```
Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]

Explanation:
- Spell 0 (strength 5): 5√ó[1,2,3,4,5] = [5,10,15,20,25]
  ‚úì 4 pairs successful (products >= 7): [10,15,20,25]

- Spell 1 (strength 1): 1√ó[1,2,3,4,5] = [1,2,3,4,5]
  ‚úó 0 pairs successful (all products < 7)

- Spell 2 (strength 3): 3√ó[1,2,3,4,5] = [3,6,9,12,15]
  ‚úì 3 pairs successful (products >= 7): [9,12,15]
```

### Example 2:
```
Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]

Explanation:
- Spell 0 (strength 3): 3√ó[8,5,8] = [24,15,24] ‚Üí 2 successful
- Spell 1 (strength 1): 1√ó[8,5,8] = [8,5,8] ‚Üí 0 successful
- Spell 2 (strength 2): 2√ó[8,5,8] = [16,10,16] ‚Üí 2 successful
```

### Constraints:
```
‚Ä¢ n == spells.length
‚Ä¢ m == potions.length
‚Ä¢ 1 <= n, m <= 10‚Åµ
‚Ä¢ 1 <= spells[i], potions[i] <= 10‚Åµ
‚Ä¢ 1 <= success <= 10¬π‚Å∞
```

---

## üí° Solution Approach

### Intuition

**Brute Force (TLE)**: Check every spell-potion pair ‚Üí `O(n√óm)` ‚ö†Ô∏è Too slow!

**Optimized Approach**:
1. Sort potions once
2. For each spell, use binary search to find valid potions
3. All potions beyond the threshold are valid (contiguous range)

### Why This Works

After sorting potions, if `potions[i]` is valid for a spell, then all `potions[j]` where `j > i` are also valid because they're larger values.

**Key Insight**: For a spell with strength `s`:
```
s √ó potion >= success
potion >= success / s
potion >= ‚åàsuccess / s‚åâ  (ceiling division)
```

We need to find the **first** potion that satisfies this condition using binary search.

---

## üîç Algorithm Steps

### Step-by-Step Process

1. **Preprocess**: Sort the `potions` array
   ```
   Time: O(m log m)
   ```

2. **For each spell** in `spells`:

   a. Calculate minimum required potion strength:
   ```python
   min_potion = ‚åàsuccess / spell‚åâ
   min_potion = (success + spell - 1) // spell  # Integer ceiling division
   ```

   b. Binary search for the first valid potion:
   ```python
   idx = bisect_left(potions, min_potion)
   ```

   c. Count valid potions:
   ```python
   count = len(potions) - idx
   ```

   ```
   Time per spell: O(log m)
   Total for all spells: O(n log m)
   ```

3. **Total Time Complexity**: `O(m log m + n log m)`

---

## üíª Code Implementation

### Python Solution

```python
from typing import List
import bisect

class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        """
        Find number of successful pairs for each spell using binary search.

        Args:
            spells: List of spell strengths
            potions: List of potion strengths
            success: Minimum product threshold

        Returns:
            List where result[i] = count of valid potions for spells[i]
        """
        # Sort potions to enable binary search
        potions.sort()
        m = len(potions)
        result = []

        for spell in spells:
            # Calculate minimum potion needed: spell √ó potion >= success
            # Rearrange: potion >= success / spell
            # Use ceiling division to avoid floating point errors
            min_potion = (success + spell - 1) // spell

            # Binary search for first potion >= min_potion
            idx = bisect.bisect_left(potions, min_potion)

            # All potions from idx to end are valid
            count = m - idx
            result.append(count)

        return result
```

### Alternative: Manual Binary Search

```python
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        m = len(potions)
        result = []

        for spell in spells:
            min_potion = (success + spell - 1) // spell

            # Manual binary search
            left, right = 0, m
            while left < right:
                mid = (left + right) // 2
                if potions[mid] < min_potion:
                    left = mid + 1
                else:
                    right = mid

            result.append(m - left)

        return result
```

---

## üìä Complexity Analysis

| Metric | Complexity | Breakdown |
|--------|-----------|-----------|
| **Time** | `O((n+m) log m)` | Sort: `O(m log m)` + Binary search for each spell: `O(n log m)` |
| **Space** | `O(log m)` to `O(m)` | Sorting space (depends on implementation) + `O(n)` for result (required output) |

### Detailed Analysis

- **Sorting**: `O(m log m)`
  - Must sort potions array once

- **Binary Search per Spell**: `O(log m)`
  - Performed `n` times ‚Üí `O(n log m)`

- **Total Time**: `O(m log m + n log m)` = `O((n+m) log m)`

- **Space Complexity**:
  - Sorting: `O(log m)` for quicksort, `O(m)` for mergesort
  - Result array: `O(n)` (required, doesn't count as extra space)
  - **Effective space**: `O(log m)` to `O(m)` depending on sort implementation

---

## üéØ Key Insights & Tricks

### 1. **Ceiling Division Without Math.ceil()**
```python
# ‚ùå Avoid floating point precision issues
min_potion = math.ceil(success / spell)

# ‚úÖ Integer-only ceiling division
min_potion = (success + spell - 1) // spell
```

**Why?**: For large values (success up to 10¬π‚Å∞), floating point division can lose precision.

**Formula**: `‚åàa/b‚åâ = (a + b - 1) // b`

### 2. **Binary Search: bisect_left vs bisect_right**
```python
# We want FIRST potion where potion >= min_potion
idx = bisect.bisect_left(potions, min_potion)

# ‚úì Correct: Finds leftmost insertion point
# All potions[idx:] satisfy the condition
```

### 3. **Why Sorting Doesn't Affect Answer**
We don't care about the **order** of potions, only **how many** are valid for each spell. Sorting preserves counts.

### 4. **Edge Cases Handled**
- ‚úÖ No valid potions ‚Üí Returns 0
- ‚úÖ All potions valid ‚Üí Returns m
- ‚úÖ Large values (success = 10¬π‚Å∞) ‚Üí Integer division handles it
- ‚úÖ Duplicate potions ‚Üí Binary search finds correct position

---

## üß™ Test Cases & Walkthrough

### Test Case 1: Basic Example
```python
spells = [5, 1, 3]
potions = [1, 2, 3, 4, 5]
success = 7

# Step 1: Sort potions ‚Üí [1, 2, 3, 4, 5] (already sorted)

# Step 2: Process each spell
Spell 5: min_potion = ‚åà7/5‚åâ = 2
         potions[1:] = [2,3,4,5] ‚Üí count = 4

Spell 1: min_potion = ‚åà7/1‚åâ = 7
         no potions >= 7 ‚Üí count = 0

Spell 3: min_potion = ‚åà7/3‚åâ = 3
         potions[2:] = [3,4,5] ‚Üí count = 3

Output: [4, 0, 3] ‚úì
```

### Test Case 2: Duplicates
```python
spells = [3, 1, 2]
potions = [8, 5, 8]
success = 16

# Step 1: Sort ‚Üí [5, 8, 8]

Spell 3: min = ‚åà16/3‚åâ = 6 ‚Üí idx=1 ‚Üí count = 2 (potions [8,8])
Spell 1: min = ‚åà16/1‚åâ = 16 ‚Üí idx=3 ‚Üí count = 0
Spell 2: min = ‚åà16/2‚åâ = 8 ‚Üí idx=1 ‚Üí count = 2 (potions [8,8])

Output: [2, 0, 2] ‚úì
```

### Test Case 3: Edge Cases
```python
# All successful
spells = [10], potions = [1, 2, 3], success = 5
Output: [3]  # All 10√ó[1,2,3] >= 5

# None successful
spells = [1], potions = [1, 2, 3], success = 100
Output: [0]  # No products >= 100

# Large values
spells = [100000], potions = [100000], success = 10000000000
Output: [1]  # 100000 √ó 100000 = 10^10
```

---

## üîÑ Alternative Approaches

### Approach 1: Two Pointers (Not Optimal Here)
- Requires sorting both arrays ‚Üí Loses spell order
- Would need extra space to track original indices
- ‚ùå Not recommended

### Approach 2: Brute Force (TLE)
```python
def successfulPairs(self, spells, potions, success):
    result = []
    for spell in spells:
        count = sum(1 for potion in potions if spell * potion >= success)
        result.append(count)
    return result

# Time: O(n √ó m) ‚Üí TLE for large inputs
```

### Approach 3: HashMap + Sorting (Unnecessary)
- Same time complexity as our solution
- More space usage
- ‚ùå No benefit over binary search approach

---

## üìù Common Mistakes to Avoid

1. **Using floating point division**
   ```python
   # ‚ùå Wrong
   min_potion = math.ceil(success / spell)  # Precision issues!

   # ‚úÖ Correct
   min_potion = (success + spell - 1) // spell
   ```

2. **Using bisect_right instead of bisect_left**
   ```python
   # ‚ùå Wrong for edge cases
   idx = bisect.bisect_right(potions, min_potion)

   # ‚úÖ Correct
   idx = bisect.bisect_left(potions, min_potion)
   ```

3. **Forgetting to sort**
   ```python
   # ‚ùå Binary search requires sorted array!
   ```

4. **Integer overflow concerns**
   - Python handles big integers automatically ‚úì
   - In Java/C++, use `long` type

---

## üéì Related Problems

| Problem | Difficulty | Similarity |
|---------|-----------|------------|
| [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) | Medium | Binary search on answer |
| [2563. Count Fair Pairs](https://leetcode.com/problems/count-the-number-of-fair-pairs/) | Medium | Binary search + sorting |
| [1498. Number of Subsequences](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/) | Medium | Two pointers + sorting |
| [658. Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/) | Medium | Binary search |

---

## üí≠ Interviewer Questions & Answers

**Q: Can we optimize space complexity?**
A: We can sort in-place, reducing extra space to O(1) (or O(log m) for recursion stack). The O(n) result array is required output.

**Q: What if we can't modify the input?**
A: Create a copy of potions ‚Üí Space becomes O(m). Time complexity unchanged.

**Q: How would you handle overflow in other languages?**
A: Use `long long` in C++ or `long` in Java. Check: `success <= (long)spell * potion`.

**Q: Can we parallelize this?**
A: Yes! After sorting, each spell's binary search is independent ‚Üí Parallel processing for O(log m) time with n processors.

---

