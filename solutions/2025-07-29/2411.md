# LeetCode 2411: Smallest Subarrays With Maximum Bitwise OR

## Problem Statement

You are given a 0-indexed array `nums` of length `n`, consisting of non-negative integers. For each index `i` from `0` to `n - 1`, you must determine the size of the minimum sized non-empty subarray of `nums` starting at `i` (inclusive) that has the maximum possible bitwise OR.

## Solution Approach

This problem requires finding the shortest subarray starting at each position that achieves the maximum possible bitwise OR from that position. The key insight is using bit manipulation and tracking the rightmost occurrence of each bit.

### Algorithm Explanation

1. **Bit Position Tracking**: For each bit position (0-31), track the rightmost index where that bit appears as 1
2. **Right-to-Left Processing**: Process array from right to left to maintain bit position information
3. **Maximum Reach Calculation**: For each starting position, find the furthest position needed to include all required bits

### Code Breakdown

```python
def smallestSubarrays(self, nums: List[int]) -> List[int]:
    n = len(nums)
    answer = [0] * n
    
    # 對於每個bit位置，記錄最後一次出現1的位置
    last_bit_pos = [-1] * 32  # 32位整數
    
    # 從右往左處理每個位置
    for i in range(n - 1, -1, -1):
        # 更新當前數字中為1的bit位置
        for bit in range(32):
            if nums[i] & (1 << bit):
                last_bit_pos[bit] = i
        
        # 找到最遠的需要包含的位置
        max_reach = i
        for bit in range(32):
            if last_bit_pos[bit] != -1:
                max_reach = max(max_reach, last_bit_pos[bit])
        
        # 子數組長度 = max_reach - i + 1
        answer[i] = max_reach - i + 1
        
    return answer
```

### Key Steps:

1. **Initialize Tracking Array**: `last_bit_pos` tracks the rightmost occurrence of each bit
2. **Process Each Position**: For each position `i` from right to left:
   - Update bit positions for current number
   - Find the maximum reach needed to include all bits
   - Calculate subarray length as `max_reach - i + 1`

### Time Complexity Analysis

- **Time Complexity**: O(n × 32) = O(n), where n is the array length
- **Space Complexity**: O(1), using constant extra space for bit tracking

### Why This Works

**Bitwise OR Properties**:
- OR operation is monotonic (never decreases)
- To achieve maximum OR from position i, we need all bits that appear in the suffix
- The shortest subarray must extend to the rightmost occurrence of any required bit

**Example Walkthrough**:
For `nums = [1,0,2,1,3]`, the algorithm efficiently finds that:
- From index 0: need to reach index 2 to get all bits → length 3
- From index 1: need to reach index 3 to get all bits → length 3
- From index 2: need to reach index 3 to get all bits → length 2
- And so on...

This approach handles edge cases like all-zero arrays efficiently, where each position only needs itself (length 1).