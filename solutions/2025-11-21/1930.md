# 1930. Unique Length-3 Palindromic Subsequences

## Problem Description

**Difficulty**: Medium

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".

## Solution Approach

### Method: First and Last Occurrence with Set

The key insight is that for a palindromic subsequence of length 3, the first and last characters must be the same. So we can iterate through each possible character (a-z) and:
1. Find the first and last occurrence of that character
2. Count the unique characters between these positions
3. Each unique middle character forms a distinct palindrome

### Algorithm Steps:

1. For each character from 'a' to 'z':
   - Find the first occurrence of the character in the string
   - Find the last occurrence of the character in the string
2. If the character appears at least twice (first < last):
   - Extract the substring between first and last occurrence
   - Count unique characters in this substring using a set
   - Add the count to the result (each unique char forms a palindrome: char + middle + char)
3. Return the total count

### Why This Works:

For string "aabca":
- Character 'a': first at index 0, last at index 4
  - Middle chars: "abc" → set {a, b, c} → palindromes: "aaa", "aba", "aca" (3 palindromes)
- Character 'b': appears only once → skip
- Character 'c': appears only once → skip
- Total: 3 unique palindromes

For string "bbcbaba":
- Character 'b': first at 0, last at 5
  - Middle chars: "bcbab" → set {c, b, a} → palindromes: "bcb", "bbb", "bab" (3 palindromes)
- Character 'a': first at 4, last at 6
  - Middle chars: "b" → set {b} → palindromes: "aba" (1 palindrome)
- Total: 4 unique palindromes

## Code Implementation

```python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        result = 0

        # Check each character a-z
        for char in 'abcdefghijklmnopqrstuvwxyz':
            # Find first and last occurrence
            first = s.find(char)
            last = s.rfind(char)

            # If character appears at least twice
            if first != -1 and first < last:
                # Count unique characters between first and last occurrence
                middle_chars = set(s[first + 1:last])
                result += len(middle_chars)

        return result
```

## Complexity Analysis

- **Time Complexity**: O(26 × n) = O(n), where n is the length of string s
  - We iterate through 26 characters (constant)
  - For each character, find() and rfind() each take O(n)
  - Creating the set for middle characters takes O(n) in worst case
- **Space Complexity**: O(1)
  - The set of middle characters has at most 26 elements (lowercase English letters)
  - All other variables use constant space

## Example Tests

**Example 1:**
```
Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
```

**Example 2:**
```
Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
```

**Example 3:**
```
Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
```

## Key Points

1. For length-3 palindromes, only the outer characters need to match
2. Using first and last occurrence ensures we capture all possible middle characters
3. Using a set automatically handles uniqueness requirement
4. Fixed alphabet size (26 letters) keeps complexity linear

---

# 1930. 長度為3的不同回文子序列

## 問題描述

**難度**: Medium

給定一個字串 s，返回作為 s 的子序列的長度為 3 的不同回文的數量。

注意，即使有多種方法獲得相同的子序列，它仍然只計數一次。

回文是正讀和反讀都相同的字串。

子序列是從原始字串刪除一些字符（可以不刪除）而不改變剩餘字符的相對順序生成的新字串。

## 解題思路

### 方法：首次和最後出現位置配合集合

關鍵洞察是對於長度為 3 的回文子序列，第一個和最後一個字符必須相同。因此我們可以遍歷每個可能的字符（a-z）並且：
1. 找到該字符的首次和最後出現位置
2. 計算這些位置之間的唯一字符數量
3. 每個唯一的中間字符都形成一個不同的回文

### 算法步驟:

1. 對於從 'a' 到 'z' 的每個字符：
   - 在字串中找到該字符的首次出現位置
   - 在字串中找到該字符的最後出現位置
2. 如果該字符至少出現兩次（first < last）：
   - 提取首次和最後出現位置之間的子字串
   - 使用集合計算此子字串中的唯一字符
   - 將計數加到結果中（每個唯一字符形成一個回文：char + middle + char）
3. 返回總計數

### 為什麼這樣做有效：

對於字串 "aabca"：
- 字符 'a'：首次在索引 0，最後在索引 4
  - 中間字符："abc" → 集合 {a, b, c} → 回文："aaa", "aba", "aca"（3個回文）
- 字符 'b'：只出現一次 → 跳過
- 字符 'c'：只出現一次 → 跳過
- 總計：3 個不同的回文

對於字串 "bbcbaba"：
- 字符 'b'：首次在 0，最後在 5
  - 中間字符："bcbab" → 集合 {c, b, a} → 回文："bcb", "bbb", "bab"（3個回文）
- 字符 'a'：首次在 4，最後在 6
  - 中間字符："b" → 集合 {b} → 回文："aba"（1個回文）
- 總計：4 個不同的回文

## 代碼實現

```python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        result = 0

        # 檢查每個字符 a-z
        for char in 'abcdefghijklmnopqrstuvwxyz':
            # 找到首次和最後出現位置
            first = s.find(char)
            last = s.rfind(char)

            # 如果字符至少出現兩次
            if first != -1 and first < last:
                # 計算首次和最後出現位置之間的唯一字符
                middle_chars = set(s[first + 1:last])
                result += len(middle_chars)

        return result
```

## 複雜度分析

- **時間複雜度**: O(26 × n) = O(n)，其中 n 是字串 s 的長度
  - 我們遍歷 26 個字符（常數）
  - 對於每個字符，find() 和 rfind() 各需要 O(n)
  - 創建中間字符的集合在最壞情況下需要 O(n)
- **空間複雜度**: O(1)
  - 中間字符的集合最多有 26 個元素（小寫英文字母）
  - 所有其他變量使用常數空間

## 範例測試

**Example 1:**
```
Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
```

**Example 2:**
```
Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
```

**Example 3:**
```
Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
```

## 關鍵要點

1. 對於長度為 3 的回文，只有外部字符需要匹配
2. 使用首次和最後出現位置確保我們捕獲所有可能的中間字符
3. 使用集合自動處理唯一性要求
4. 固定的字母表大小（26 個字母）保持複雜度為線性
