# 1018. Binary Prefix Divisible By 5

**Difficulty**: Medium
**Topics**: Array, Math, Bit Manipulation
**Link**: https://leetcode.com/problems/binary-prefix-divisible-by-5/

## Problem Description

Given a binary array `nums` (0-indexed), we define `xi` as the number whose binary representation is the subarray `nums[0..i]` (from most-significant-bit to least-significant-bit).

Return an array of booleans `answer` where `answer[i]` is `true` if `xi` is divisible by 5.

### Examples

**Example 1:**
```
Input: nums = [0,1,1]
Output: [true,false,false]
Explanation:
- x0 = 0 (binary: 0) → divisible by 5 ✓
- x1 = 1 (binary: 01) → not divisible by 5
- x2 = 3 (binary: 011) → not divisible by 5
```

**Example 2:**
```
Input: nums = [1,1,1]
Output: [false,false,false]
Explanation:
- x0 = 1 (binary: 1) → not divisible by 5
- x1 = 3 (binary: 11) → not divisible by 5
- x2 = 7 (binary: 111) → not divisible by 5
```

### Constraints
- `1 <= nums.length <= 10^5`
- `nums[i]` is either `0` or `1`

## Solution Approach

### Key Insight

The critical insight is that we **don't need to compute the actual decimal value** of each prefix, which could be astronomically large (up to 2^100000). Instead, we only care whether the number is divisible by 5.

We can use the **modular arithmetic property**:
```
(a * b + c) % m = ((a % m) * b + c) % m
```

This allows us to keep track of only the remainder when dividing by 5, rather than the full number.

### Algorithm

1. Initialize `current = 0` (represents the current number modulo 5)
2. For each bit in `nums`:
   - Shift left by 1 (multiply by 2): `current = current * 2`
   - Add the new bit: `current = current + nums[i]`
   - Take modulo 5 to keep the number small: `current = current % 5`
   - Check if `current == 0` (divisible by 5)

### Example Walkthrough

For `nums = [1, 0, 1, 0, 0]`:

| Step | Binary | Decimal | current * 2 + bit | current % 5 | Divisible by 5? |
|------|--------|---------|-------------------|-------------|-----------------|
| 0    | 1      | 1       | 0*2 + 1 = 1       | 1           | False           |
| 1    | 10     | 2       | 1*2 + 0 = 2       | 2           | False           |
| 2    | 101    | 5       | 2*2 + 1 = 5       | 0           | True ✓          |
| 3    | 1010   | 10      | 0*2 + 0 = 0       | 0           | True ✓          |
| 4    | 10100  | 20      | 0*2 + 0 = 0       | 0           | True ✓          |

Result: `[False, False, True, True, True]`

### Why This Works

When building a binary number left-to-right:
- Each new bit position means we shift everything left by 1 (multiply by 2)
- Then we add the new bit (0 or 1)

For example:
- Binary `10` → add bit `1` → `10 * 2 + 1 = 21` → binary `101`

By keeping only `current % 5`, we maintain the divisibility information without storing huge numbers.

## Complexity Analysis

- **Time Complexity**: O(n)
  - Single pass through the array
  - Each operation is O(1)

- **Space Complexity**: O(n)
  - O(n) for the output array
  - O(1) extra space for variables

## Code Implementation

```python
class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        answer = []
        current = 0

        for bit in nums:
            current = (current * 2 + bit) % 5
            answer.append(current == 0)

        return answer
```

## Edge Cases

1. **Single element**: `[0]` → `[True]`, `[1]` → `[False]`
2. **All zeros**: `[0, 0, 0]` → All `True` (0 is divisible by 5)
3. **All ones**: `[1, 1, 1]` → All `False` (1, 3, 7 not divisible by 5)
4. **Maximum length**: Array with 10^5 elements (handled efficiently with modulo)

## Related Topics

- **Modular Arithmetic**: Using `% 5` to avoid overflow
- **Binary to Decimal Conversion**: Building numbers iteratively
- **Bit Manipulation**: Understanding binary representation

## Tags
`#array` `#math` `#modular-arithmetic` `#binary` `#bit-manipulation`
