# 1339. Maximum Product of Splitted Binary Tree

## 問題描述 / Problem Description

**難度 / Difficulty:** Medium

Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.

Note that you need to maximize the answer before taking the mod and not after taking it.

**Example 1:**
```
Input: root = [1,2,3,4,5,6]
Output: 110
Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)
```

**Example 2:**
```
Input: root = [1,null,2,3,4,null,null,5,6]
Output: 90
Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6. Their product is 90 (15*6)
```

**Constraints:**
- The number of nodes in the tree is in the range [2, 5 * 10^4].
- 1 <= Node.val <= 10^4

## 解題思路 / Approach

### 中文思路
1. **計算總和**: 首先遍歷整棵樹，計算所有節點值的總和 `total_sum`
2. **遍歷所有可能的分割**: 對於每個節點，我們可以考慮移除它與父節點之間的邊
3. **計算乘積**: 當移除某條邊時，會產生兩個子樹：
   - 一個子樹的和為 `subtree_sum`（被分離出去的部分）
   - 另一個子樹的和為 `total_sum - subtree_sum`（剩餘的部分）
   - 乘積為 `subtree_sum * (total_sum - subtree_sum)`
4. **找最大值**: 追蹤所有可能分割的最大乘積
5. **返回結果**: 最後對 10^9 + 7 取模

### English Approach
1. **Calculate Total Sum**: First traverse the entire tree to calculate the sum of all node values `total_sum`
2. **Try All Possible Splits**: For each node, we can consider removing the edge between it and its parent
3. **Calculate Product**: When an edge is removed, two subtrees are created:
   - One subtree has sum = `subtree_sum` (the separated part)
   - The other subtree has sum = `total_sum - subtree_sum` (the remaining part)
   - Product = `subtree_sum * (total_sum - subtree_sum)`
4. **Find Maximum**: Track the maximum product among all possible splits
5. **Return Result**: Finally return the result modulo 10^9 + 7

## 複雜度分析 / Complexity Analysis

- **時間複雜度 / Time Complexity**: O(n)
  - 需要遍歷樹兩次：一次計算總和，一次找最大乘積
  - We need to traverse the tree twice: once to calculate total sum, once to find max product

- **空間複雜度 / Space Complexity**: O(h)
  - h 是樹的高度，遞迴調用的棧空間
  - h is the height of the tree, for the recursive call stack

## Code Implementation

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7

        # First pass: Calculate total sum of all nodes
        def calculate_total_sum(node):
            if not node:
                return 0
            return node.val + calculate_total_sum(node.left) + calculate_total_sum(node.right)

        total_sum = calculate_total_sum(root)
        max_product = 0

        # Second pass: For each subtree, calculate the product
        def calculate_subtree_sum(node):
            nonlocal max_product

            if not node:
                return 0

            # Calculate sum of current subtree
            left_sum = calculate_subtree_sum(node.left)
            right_sum = calculate_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # If we remove the edge above this subtree:
            # One part has sum = subtree_sum
            # Other part has sum = total_sum - subtree_sum
            product = subtree_sum * (total_sum - subtree_sum)
            max_product = max(max_product, product)

            return subtree_sum

        calculate_subtree_sum(root)

        return max_product % MOD
```

## 代碼實現

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        MOD = 10**9 + 7

        # 第一次遍歷：計算所有節點的總和
        def calculate_total_sum(node):
            if not node:
                return 0
            return node.val + calculate_total_sum(node.left) + calculate_total_sum(node.right)

        total_sum = calculate_total_sum(root)
        max_product = 0

        # 第二次遍歷：對於每個子樹，計算乘積
        def calculate_subtree_sum(node):
            nonlocal max_product

            if not node:
                return 0

            # 計算當前子樹的和
            left_sum = calculate_subtree_sum(node.left)
            right_sum = calculate_subtree_sum(node.right)
            subtree_sum = node.val + left_sum + right_sum

            # 如果移除這個子樹上方的邊：
            # 一部分的和 = subtree_sum
            # 另一部分的和 = total_sum - subtree_sum
            product = subtree_sum * (total_sum - subtree_sum)
            max_product = max(max_product, product)

            return subtree_sum

        calculate_subtree_sum(root)

        return max_product % MOD
```

## 測試案例 / Test Cases

```python
# Test Case 1
root1 = TreeNode(1)
root1.left = TreeNode(2, TreeNode(4), TreeNode(5))
root1.right = TreeNode(3, TreeNode(6))
# Expected: 110

# Test Case 2
root2 = TreeNode(1)
root2.right = TreeNode(2, TreeNode(3), TreeNode(4))
root2.right.left.left = TreeNode(5)
root2.right.left.right = TreeNode(6)
# Expected: 90
```
