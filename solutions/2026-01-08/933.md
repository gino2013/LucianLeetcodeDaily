# 933. Number of Recent Calls

**Difficulty:** Easy

## Problem Description

You have a `RecentCounter` class which counts the number of recent requests within a certain time frame.

Implement the `RecentCounter` class:

- `RecentCounter()` Initializes the counter with zero recent requests.
- `int ping(int t)` Adds a new request at time `t`, where `t` represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range `[t - 3000, t]`.

It is guaranteed that every call to `ping` uses a strictly larger value of `t` than the previous call.

## Examples

### Example 1:

```
Input
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
Output
[null, 1, 2, 3, 3]

Explanation
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3
```

## Constraints:

- `1 <= t <= 10^9`
- Each test case will call `ping` with strictly increasing values of `t`.
- At most `10^4` calls will be made to `ping`.

## Solution Approach

The key insight is to use a **queue (deque)** data structure to maintain a sliding window of timestamps:

1. **Add new timestamp:** When `ping(t)` is called, append `t` to the queue
2. **Remove old timestamps:** Remove all timestamps from the front of the queue that are older than `t - 3000`
3. **Return count:** The size of the queue represents the number of valid requests

### Time Complexity
- **O(1)** amortized per `ping` operation - each timestamp is added once and removed once

### Space Complexity
- **O(W)** where W is the maximum size of the sliding window (at most 3000 milliseconds worth of requests)

### Why use a deque?
- Efficient O(1) operations for both adding to the end (`append`) and removing from the front (`popleft`)
- Perfect for implementing a sliding window pattern
- Automatically maintains the order of timestamps
