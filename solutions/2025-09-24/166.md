# 166. Fraction to Recurring Decimal

## Problem Description

**Difficulty**: Medium

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

If multiple answers are possible, return any of them.

It is guaranteed that the length of the answer string is less than 10^4 for all the given inputs.

**Constraints:**
- -2^31 <= numerator, denominator <= 2^31 - 1
- denominator != 0

## Solution Approach

### Method: Long Division with Remainder Tracking

This problem simulates the long division process while detecting repeating patterns in the fractional part. The key insight is that when performing long division, if we encounter the same remainder twice, we've found a repeating cycle.

### Algorithm Steps:

1. **Handle edge cases**: Check if numerator is 0, return "0"
2. **Determine sign**: Use XOR to check if result should be negative
3. **Calculate integer part**: Use integer division and store the result
4. **Process fractional part**:
   - Track remainders and their positions in a hash map
   - When a remainder repeats, insert parentheses around the repeating part
   - Continue division until remainder becomes 0 or we find a cycle

## Code Implementation

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"

        result = []

        # Handle negative sign
        if (numerator < 0) ^ (denominator < 0):
            result.append("-")

        # Work with absolute values
        numerator = abs(numerator)
        denominator = abs(denominator)

        # Integer part
        result.append(str(numerator // denominator))
        numerator %= denominator

        if numerator == 0:
            return "".join(result)

        # Fractional part
        result.append(".")
        remainder_map = {}  # remainder -> position in result

        while numerator != 0:
            if numerator in remainder_map:
                # Found repeating part
                index = remainder_map[numerator]
                result.insert(index, "(")
                result.append(")")
                break

            remainder_map[numerator] = len(result)
            numerator *= 10
            result.append(str(numerator // denominator))
            numerator %= denominator

        return "".join(result)
```

## Complexity Analysis

- **Time Complexity**: O(d) where d is the denominator. In the worst case, we might need to process all possible remainders (0 to d-1) before finding a repeat.
- **Space Complexity**: O(d) for storing the remainder positions in the hash map and the result string.

## Example Tests

**Example 1:**
```
Input: numerator = 1, denominator = 2
Output: "0.5"
```

**Example 2:**
```
Input: numerator = 2, denominator = 1
Output: "2"
```

**Example 3:**
```
Input: numerator = 4, denominator = 333
Output: "0.(012)"
```

## Key Points

1. **XOR for sign detection**: `(numerator < 0) ^ (denominator < 0)` elegantly handles all sign combinations
2. **Remainder tracking**: The key insight is that repeating remainders indicate repeating decimal patterns
3. **String building**: Using a list and `"".join()` is more efficient than string concatenation
4. **Edge case handling**: Handle zero numerator early and check for exact division after integer part

---

# 166. 分數到小數

## 問題描述

**難度**: Medium

給定兩個整數分別代表分數的分子和分母，以字符串格式返回分數。

如果小數部分是循環的，請將循環部分用括號括起來。

如果有多個答案，返回其中任何一個即可。

保證對於所有給定的輸入，答案字符串的長度小於 10^4。

**約束條件:**
- -2^31 <= numerator, denominator <= 2^31 - 1
- denominator != 0

## 解題思路

### 方法：長除法配合餘數追蹤

此題模擬長除法過程，同時檢測小數部分的重複模式。關鍵洞察是在執行長除法時，如果遇到相同的餘數兩次，就找到了重複循環。

### 算法步驟:

1. **處理邊界情況**: 檢查分子是否為 0，如果是則返回 "0"
2. **確定符號**: 使用 XOR 檢查結果是否應該為負數
3. **計算整數部分**: 使用整數除法並存儲結果
4. **處理小數部分**:
   - 在哈希表中追蹤餘數及其位置
   - 當餘數重複時，在重複部分周圍插入括號
   - 繼續除法直到餘數變為 0 或找到循環

## 代碼實現

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"

        result = []

        # 處理負號
        if (numerator < 0) ^ (denominator < 0):
            result.append("-")

        # 使用絕對值工作
        numerator = abs(numerator)
        denominator = abs(denominator)

        # 整數部分
        result.append(str(numerator // denominator))
        numerator %= denominator

        if numerator == 0:
            return "".join(result)

        # 小數部分
        result.append(".")
        remainder_map = {}  # 餘數 -> 結果中的位置

        while numerator != 0:
            if numerator in remainder_map:
                # 找到重複部分
                index = remainder_map[numerator]
                result.insert(index, "(")
                result.append(")")
                break

            remainder_map[numerator] = len(result)
            numerator *= 10
            result.append(str(numerator // denominator))
            numerator %= denominator

        return "".join(result)
```

## 複雜度分析

- **時間複雜度**: O(d) 其中 d 是分母。最壞情況下，我們可能需要處理所有可能的餘數 (0 到 d-1) 才能找到重複。
- **空間複雜度**: O(d) 用於在哈希表中存儲餘數位置和結果字符串。

## 範例測試

**Example 1:**
```
Input: numerator = 1, denominator = 2
Output: "0.5"
```

**Example 2:**
```
Input: numerator = 2, denominator = 1
Output: "2"
```

**Example 3:**
```
Input: numerator = 4, denominator = 333
Output: "0.(012)"
```

## 關鍵要點

1. **XOR 符號檢測**: `(numerator < 0) ^ (denominator < 0)` 優雅地處理所有符號組合
2. **餘數追蹤**: 關鍵洞察是重複的餘數表示重複的小數模式
3. **字符串構建**: 使用列表和 `"".join()` 比字符串拼接更高效
4. **邊界情況處理**: 及早處理零分子，在整數部分後檢查精確除法
